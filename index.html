<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Sleep Call — improved</title>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    body{font-family:sans-serif;background:#111;color:#eee;text-align:center;padding:18px}
    video{width:40%;margin:8px;border-radius:10px;border:1px solid #333}
    input,button{padding:8px;margin:6px;border-radius:6px;border:none}
    button{background:#4cafef;color:#fff;cursor:pointer}
  </style>
</head>
<body>
  <h1>Sleep Call 💫 (improved)</h1>

  <div>
    <input id="roomInput" placeholder="room name (e.g. abc123)" />
    <button id="joinBtn">Join Room</button>
  </div>

  <div>
    <label>Timer (minutes)</label>
    <input id="timerInput" type="number" placeholder="60" />
    <button id="startCallBtn">Start Call</button>
    <button id="clearSignalsBtn">Clear Room Signals</button>
  </div>

  <div>
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

<script>
/* ========== CONFIG - replace these ========== */
const SUPABASE_URL = "https://YOUR-PROJECT-ID.supabase.co";
const SUPABASE_KEY = "YOUR-ANON-KEY";
/* ============================================ */

const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

let pc = null;
let localStream = null;
let roomName = null;
const clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2);
let subscription = null;
let timerId = null;

const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

document.getElementById('joinBtn').onclick = async () => {
  roomName = document.getElementById('roomInput').value.trim();
  if (!roomName) return alert('Enter a room name');
  alert('Joined room: ' + roomName);
  await startSubscription(); // subscribe early so we receive incoming messages
};

document.getElementById('clearSignalsBtn').onclick = async () => {
  if (!roomName) return alert('Join a room first');
  // Note: this requires RLS allow delete for anon OR do it manually in Supabase table editor
  try {
    await supabase.from('signals').delete().eq('room', roomName);
    alert('Cleared signals for room: ' + roomName);
  } catch (e) {
    alert('Could not clear signals (you may not have DELETE policy). Clear in Supabase table editor.');
    console.error(e);
  }
};

async function startSubscription(){
  if (!roomName) return;
  if (subscription) return; // already subscribed

  subscription = supabase
    .channel('room-' + roomName)
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'signals',
      filter: `room=eq.${roomName}`
    }, async (payload) => {
      // payload.new is the inserted row
      try {
        const row = payload.new;
        const type = row.type;
        const data = row.data; // should be the object we inserted
        // Ignore our own messages:
        if (data && data.clientId === clientId) return;

        console.log('Received signal', type, data);

        if (!pc) {
          console.warn('No peerConnection yet — ignoring for now');
          return;
        }

        if (type === 'offer') {
          // remote offer -> setRemoteDescription, create & send answer
          const desc = { type: data.offerType || 'offer', sdp: data.sdp };
          await pc.setRemoteDescription(new RTCSessionDescription(desc));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await supabase.from('signals').insert({
            room: roomName,
            type: 'answer',
            data: { sdp: answer.sdp, answerType: answer.type, clientId }
          });
        } else if (type === 'answer') {
          const desc = { type: data.answerType || 'answer', sdp: data.sdp };
          await pc.setRemoteDescription(new RTCSessionDescription(desc));
        } else if (type === 'ice') {
          const cand = data.candidate;
          if (cand) {
            try {
              await pc.addIceCandidate(new RTCIceCandidate(cand));
            } catch (e) {
              console.warn('addIceCandidate failed', e);
            }
          }
        }
      } catch (err) {
        console.error('Error processing incoming signal', err);
      }
    })
    .subscribe();

  console.log('Subscribed to room channel');
}

document.getElementById('startCallBtn').onclick = async () => {
  if (!roomName) return alert('Join a room first');

  // get media
  try {
    localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true});
    localVideo.srcObject = localStream;
  } catch (e) {
    return alert('Could not access camera/mic: ' + e.message);
  }

  // create peer connection with STUN (add TURN here if you have one)
  pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' }
      // add TURN server here if needed
    ]
  });

  // show remote
  pc.ontrack = (ev) => {
    remoteVideo.srcObject = ev.streams[0];
    console.log('remote stream set');
  };

  // add local tracks
  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  // send ICE to supabase (include clientId)
  pc.onicecandidate = async (ev) => {
    if (ev.candidate) {
      await supabase.from('signals').insert({
        room: roomName,
        type: 'ice',
        data: { candidate: ev.candidate.toJSON(), clientId }
      });
    }
  };

  // ensure we are subscribed before we create or react to offers
  await startSubscription();

  // check if there is already an offer in this room (someone else started)
  const res = await supabase.from('signals').select('id,type,data').eq('room', roomName).eq('type','offer').order('id', { ascending: true }).limit(1);
  const existingOffer = res.data && res.data.length ? res.data[0] : null;

  if (existingOffer && existingOffer.data && existingOffer.data.clientId !== clientId) {
    // act as callee: set remote desc (offer) and create/send answer
    console.log('Found remote offer — acting as callee');
    const offerData = existingOffer.data;
    const remoteDesc = { type: offerData.offerType || 'offer', sdp: offerData.sdp };
    await pc.setRemoteDescription(new RTCSessionDescription(remoteDesc));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await supabase.from('signals').insert({
      room: roomName,
      type: 'answer',
      data: { sdp: answer.sdp, answerType: answer.type, clientId }
    });
  } else {
    // act as caller: create offer and insert
    console.log('No existing offer — acting as caller');
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    await supabase.from('signals').insert({
      room: roomName,
      type: 'offer',
      data: { sdp: offer.sdp, offerType: offer.type, clientId }
    });
  }

  // Timer handling
  const minutes = parseFloat(document.getElementById('timerInput').value);
  if (minutes > 0) {
    if (timerId) clearTimeout(timerId);
    timerId = setTimeout(()=> {
      if (pc) pc.close();
      if (localStream) localStream.getTracks().forEach(t=>t.stop());
      alert('⏰ Timer ended — call closed');
    }, minutes * 60 * 1000);
  }
};

</script>
</body>
</html>
