<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sleep Call â€” stable</title>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    body{font-family:sans-serif;background:#111;color:#eee;text-align:center;padding:18px}
    video{width:40%;margin:8px;border-radius:10px;border:1px solid #333}
    input,button{padding:8px;margin:6px;border-radius:6px;border:none}
    button{background:#4cafef;color:#fff;cursor:pointer}
  </style>
</head>
<body>
  <h1>Sleep Call ðŸ’«</h1>

  <div>
    <input id="roomInput" placeholder="room name (unique for each test)" />
    <button id="joinBtn">Join Room (subscribe)</button>
  </div>

  <div>
    <label>Timer (minutes)</label>
    <input id="timerInput" type="number" placeholder="e.g. 60" />
    <button id="startCallBtn">Start Call</button>
    <button id="endCallBtn">End Call</button>
  </div>

  <div>
    <video id="localVideo" autoplay playsinline muted></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

<script>
/* ======= CONFIG - replace with your Supabase project values ======= */
const SUPABASE_URL = "https://4pooja2005.github.io/sleep-call/";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhscXZtc2phdXVmd3Z4aHBsc215Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc4MzI5NjYsImV4cCI6MjA3MzQwODk2Nn0.aywHn23wfmOXkHFoQ2Jix469JVuk9QG7fw9FrolnvfU";
/* ================================================================= */

const supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

// small unique id to ignore our own messages
const clientId = (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2);

let roomName = null;
let pc = null;
let localStream = null;
let subscribedChannel = null;
let callActive = false;
let timerId = null;

const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

//// Utility: log prefixed
function log(...args){ console.log('[SleepCall]', ...args); }

// Subscribe to incoming signals for a room (call after Join)
async function subscribeRoom(r) {
  if (!r) return;
  if (subscribedChannel) {
    log('Already subscribed to room', r);
    return;
  }
  const channel = supabase
    .channel('room-' + r)
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'signals',
      filter: `room=eq.${r}`
    }, async (payload) => {
      const row = payload.new;
      if (!row) return;
      const { type, data } = row;
      if (!data) return;
      // ignore our own messages
      if (data.clientId === clientId) return;
      log('Received signal', type, data);

      // If we got an offer and do not yet have remote desc, answer it
      if (type === 'offer') {
        // ensure we have a pc & local tracks ready
        if (!pc) await createPeerConnectionAndAttachLocalTracks();
        try {
          await pc.setRemoteDescription({ type: data.sdpType || data.type || 'offer', sdp: data.sdp });
          log('Set remote offer. Creating answer...');
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await supabase.from('signals').insert({
            room: roomName,
            type: 'answer',
            data: { sdp: answer.sdp, sdpType: answer.type, clientId }
          });
          log('Answer sent');
        } catch (e) {
          console.error('Error handling offer', e);
        }
      } else if (type === 'answer') {
        if (!pc) { log('Received answer but no pc yet'); return; }
        try {
          await pc.setRemoteDescription({ type: data.sdpType || data.type || 'answer', sdp: data.sdp });
          log('Remote answer set');
        } catch (e) {
          console.error('Error setting remote answer', e);
        }
      } else if (type === 'ice') {
        if (!pc) { log('Received ICE but no pc yet'); return; }
        try {
          await pc.addIceCandidate(data.candidate);
          log('Added remote ICE candidate');
        } catch (e) {
          console.warn('addIceCandidate failed', e);
        }
      }
    });

  await channel.subscribe();
  subscribedChannel = channel;
  log('Subscribed to Supabase signals for room', r);
}

// Create peer connection and add local tracks (but do NOT createOffer here)
async function createPeerConnectionAndAttachLocalTracks() {
  if (pc) return pc;
  pc = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    // add TURN here if you have one
  });

  pc.ontrack = (ev) => {
    log('ontrack event', ev.streams);
    if (ev.streams && ev.streams[0]) {
      remoteVideo.srcObject = ev.streams[0];
    }
  };

  pc.onicecandidate = async (ev) => {
    if (ev.candidate) {
      try {
        await supabase.from('signals').insert({
          room: roomName,
          type: 'ice',
          data: { candidate: ev.candidate.toJSON(), clientId }
        });
        log('Sent local ICE candidate');
      } catch (e) {
        console.error('Failed to send ICE candidate', e);
      }
    }
  };

  // ensure we have localStream
  if (!localStream) {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
      log('Local media acquired');
    } catch (e) {
      alert('Camera/mic permission failed: ' + e.message);
      throw e;
    }
  }

  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  return pc;
}

// Start call flow (caller or callee depending on existing offers)
async function startCall() {
  if (!roomName) return alert('Join a room first');
  if (callActive) return alert('Call already active');
  callActive = true;
  log('Starting call...');

  // Make sure subscription is active
  if (!subscribedChannel) await subscribeRoom(roomName);

  // create pc & local tracks
  await createPeerConnectionAndAttachLocalTracks();

  // Look for an existing offer in the table
  try {
    const { data: offers, error } = await supabase
      .from('signals')
      .select('id,type,data')
      .eq('room', roomName)
      .eq('type', 'offer')
      .order('id', { ascending: true })
      .limit(1);

    if (error) { console.warn('Error fetching offers', error); }

    const existing = (offers && offers.length) ? offers[0] : null;

    if (existing && existing.data && existing.data.clientId !== clientId) {
      // a remote offer exists -> act as callee (answerer)
      log('Existing offer found -> act as callee');
      const remote = existing.data;
      await pc.setRemoteDescription({ type: remote.sdpType || remote.type || 'offer', sdp: remote.sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await supabase.from('signals').insert({
        room: roomName,
        type: 'answer',
        data: { sdp: answer.sdp, sdpType: answer.type, clientId }
      });
      log('Answer inserted into signals');
    } else {
      // no offer -> act as caller
      log('No existing offer -> act as caller and createOffer');
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await supabase.from('signals').insert({
        room: roomName,
        type: 'offer',
        data: { sdp: offer.sdp, sdpType: offer.type, clientId }
      });
      log('Offer inserted into signals');
    }
  } catch (e) {
    console.error('Error during startCall flow', e);
  }

  // Timer
  const minutes = parseFloat(document.getElementById('timerInput').value);
  if (minutes > 0) {
    timerId = setTimeout(()=> {
      log('Timer ended; ending call');
      endCall(true);
    }, minutes * 60 * 1000);
    log('Timer set for', minutes, 'minutes');
  }
}

// Graceful end
function endCall(timerEnded = false) {
  if (!callActive) return;
  callActive = false;

  if (pc) {
    try { pc.close(); } catch(e) {}
    pc = null;
  }
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }
  localVideo.srcObject = null;
  remoteVideo.srcObject = null;

  if (timerId) { clearTimeout(timerId); timerId = null; }
  log('Call ended', timerEnded ? '(timer)' : '(manual)');

  if (timerEnded) alert('â° Timer ended â€” call closed');
  else alert('ðŸ“ž Call ended manually');
}

// UI handlers
document.getElementById('joinBtn').onclick = async () => {
  const r = (document.getElementById('roomInput').value || '').trim();
  if (!r) return alert('Enter a room name');
  roomName = r;
  await subscribeRoom(roomName);
  alert('Joined room: ' + roomName + '. Now click Start Call (A should start first).');
};

document.getElementById('startCallBtn').onclick = async () => {
  await startCall();
};

document.getElementById('endCallBtn').onclick = () => endCall(false);

// Helpful debugging tip in console
log('clientId', clientId);
log('Open the console on both devices while testing to view detailed logs.');
</script>
</body>
</html>
